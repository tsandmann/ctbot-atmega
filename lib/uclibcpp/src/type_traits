/*	Copyright (C) 2005 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <basic_definitions>
#include <exception>
#include <memory>
#include <char_traits>

#ifndef __HEADER_TYPE_TRAITS
#define __HEADER_TYPE_TRAITS 1

#pragma GCC visibility push(default)

namespace std {

	struct _UCXXEXPORT __true_type{};
	struct _UCXXEXPORT __false_type{};

	template <class I> class _UCXXEXPORT __is_integer{
	public:
		typedef __false_type value;
	};

	template <> class _UCXXEXPORT __is_integer <unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <signed int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <short unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <short signed int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <signed char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <unsigned char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <long unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <long signed int>{
	public:
		typedef __true_type value;
	};

	struct __two {char __lx[2];};


	template <class _Tp> class reference_wrapper;

	template <class>
	struct __void_t { typedef void type; };

	template <class _Tp>
	struct __identity { typedef _Tp type; };

	/* std::conditional<> */
	template <bool _Bp, class _If, class _Then>
	struct _UCXXEXPORT conditional { typedef _If type; };

	template <class _If, class _Then>
	struct _UCXXEXPORT conditional<false, _If, _Then> { typedef _Then type; };

	template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


	/* integral_constant */
	template<typename _Tp, _Tp __v>
	struct integral_constant {
		static constexpr _Tp value = __v;
		typedef _Tp value_type;
		typedef integral_constant<_Tp, __v> type;
		constexpr operator value_type() const {
			return value;
		}
		constexpr value_type operator()() const {
			return value;
		}
	};

	template<typename _Tp, _Tp __v>
	constexpr _Tp integral_constant<_Tp, __v>::value;

	/// The type used as a compile-time boolean with true value.
	typedef integral_constant<bool, true> true_type;

	/// The type used as a compile-time boolean with false value.
	typedef integral_constant<bool, false> false_type;

	template<bool __v>
	using __bool_constant = integral_constant<bool, __v>;

	template<bool __v>
	using bool_constant = integral_constant<bool, __v>;

	// addressof
	template <class _Tp>
	inline _Tp*
	addressof(_Tp& __x) noexcept
	{
	return reinterpret_cast<_Tp *>(
		const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));
	}


	/* std::is_same */
	template<typename, typename >
	struct is_same: public false_type {
	};

	template<typename _Tp>
	struct is_same<_Tp, _Tp> : public true_type {
	};


	/* std::enable_if */
	template<bool, typename _Tp = void>
	struct enable_if {
	};

	// Partial specialization for true.
	template<typename _Tp>
	struct enable_if<true, _Tp> {
		typedef _Tp type;
	};


	// __lazy_and
	template <bool _Last, class ..._Preds>
	struct __lazy_and_impl;

	template <class ..._Preds>
	struct __lazy_and_impl<false, _Preds...> : false_type {};

	template <>
	struct __lazy_and_impl<true> : true_type {};

	template <class _Pred>
	struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};

	template <class _Hp, class ..._Tp>
	struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};

	template <class _P1, class ..._Pr>
	struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};

	// __lazy_or
	template <bool _List, class ..._Preds>
	struct __lazy_or_impl;

	template <class ..._Preds>
	struct __lazy_or_impl<true, _Preds...> : true_type {};

	template <>
	struct __lazy_or_impl<false> : false_type {};

	template <class _Hp, class ..._Tp>
	struct __lazy_or_impl<false, _Hp, _Tp...>
			: __lazy_or_impl<_Hp::type::value, _Tp...> {};

	template <class _P1, class ..._Pr>
	struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};

	// __lazy_not
	template <class _Pred>
	struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};

	// __and_
	template<class...> struct __and_;
	template<> struct __and_<> : true_type {};

	template<class _B0> struct __and_<_B0> : _B0 {};

	template<class _B0, class _B1>
	struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};

	template<class _B0, class _B1, class _B2, class... _Bn>
	struct __and_<_B0, _B1, _B2, _Bn...>
			: conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};

	// __or_
	template<class...> struct __or_;
	template<> struct __or_<> : false_type {};

	template<class _B0> struct __or_<_B0> : _B0 {};

	template<class _B0, class _B1>
	struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};

	template<class _B0, class _B1, class _B2, class... _Bn>
	struct __or_<_B0, _B1, _B2, _Bn...>
			: conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};

	// __not_
	template<class _Tp>
	struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};

	// is_const
	template <class _Tp> struct is_const            : public false_type {};
	template <class _Tp> struct is_const<_Tp const> : public true_type {};

	// is_volatile
	template <class _Tp> struct is_volatile               : public false_type {};
	template <class _Tp> struct is_volatile<_Tp volatile> : public true_type {};

	// remove_const
	template <class _Tp> struct remove_const            { typedef _Tp type; };
	template <class _Tp> struct remove_const<const _Tp> { typedef _Tp type; };
	template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;

	// remove_volatile
	template <class _Tp> struct remove_volatile               { typedef _Tp type; };
	template <class _Tp> struct remove_volatile<volatile _Tp> { typedef _Tp type; };
	template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;

	// remove_cv
	template <class _Tp> struct remove_cv { typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;	};
	template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;

	// remove_reference
	template <class _Tp> struct remove_reference        {typedef _Tp type;};
	template <class _Tp> struct remove_reference<_Tp&>  {typedef _Tp type;};
	template <class _Tp> struct remove_reference<_Tp&&> {typedef _Tp type;};
	template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;

	// __uncvref
	template <class _Tp>
	struct __uncvref  {
		typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
	};

	template <class _Tp>
	struct __unconstref {
		typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
	};

	template <class _Tp>
	using __uncvref_t = typename __uncvref<_Tp>::type;

	// remove_pointer
	template <class _Tp> struct remove_pointer                      {typedef _Tp type;};
	template <class _Tp> struct remove_pointer<_Tp*>                {typedef _Tp type;};
	template <class _Tp> struct remove_pointer<_Tp* const>          {typedef _Tp type;};
	template <class _Tp> struct remove_pointer<_Tp* volatile>       {typedef _Tp type;};
	template <class _Tp> struct remove_pointer<_Tp* const volatile> {typedef _Tp type;};
	template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;

	// is_void
	template <class _Tp> struct __libcpp_is_void       : public false_type {};
	template <>          struct __libcpp_is_void<void> : public true_type {};

	template <class _Tp> struct is_void
		: public __libcpp_is_void<typename remove_cv<_Tp>::type> {};


	template <class _Tp> _Tp&& __declval(int);
	template <class _Tp> _Tp   __declval(long);

	template <class _Tp>
	decltype(std::__declval<_Tp>(0))
	declval() noexcept;

	// __is_nullptr_t
	template <class _Tp> struct __is_nullptr_t_impl       : public false_type {};
	template <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

	template <class _Tp> struct __is_nullptr_t
		: public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};

	template <class _Tp> struct is_null_pointer
		: public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


	// is_integral
	template <class _Tp> struct __libcpp_is_integral                     : public false_type {};
	template <>          struct __libcpp_is_integral<bool>               : public true_type {};
	template <>          struct __libcpp_is_integral<char>               : public true_type {};
	template <>          struct __libcpp_is_integral<signed char>        : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
	template <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
	template <>          struct __libcpp_is_integral<short>              : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
	template <>          struct __libcpp_is_integral<int>                : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
	template <>          struct __libcpp_is_integral<long>               : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
	template <>          struct __libcpp_is_integral<long long>          : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};

	template <class _Tp> struct is_integral
	    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};

	// is_floating_point
	template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
	template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
	template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
	template <>          struct __libcpp_is_floating_point<long double> : public true_type {};

	template <class _Tp> struct is_floating_point
	    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};

	// is_array
	template <class _Tp> struct is_array
		: public false_type {};
	template <class _Tp> struct is_array<_Tp[]>
		: public true_type {};
	template <class _Tp, size_t _Np> struct is_array<_Tp[_Np]>
		: public true_type {};

	// is_arithmetic
	template <class _Tp> struct is_arithmetic
	    : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {};

	// is_signed
	template <class _Tp, bool = is_integral<_Tp>::value>
	struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

	template <class _Tp>
	struct __libcpp_is_signed_impl<_Tp, false> : public true_type {}; // floating point

	template <class _Tp, bool = is_arithmetic<_Tp>::value>
	struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

	template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

	template <class _Tp> struct is_signed : public __libcpp_is_signed<_Tp> {};

	// is_unsigned
	template <class _Tp, bool = is_integral<_Tp>::value>
	struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

	template <class _Tp>
	struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {}; // floating point

	template <class _Tp, bool = is_arithmetic<_Tp>::value>
	struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

	template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

	template <class _Tp> struct is_unsigned : public __libcpp_is_unsigned<_Tp> {};

	// remove_all_extents
	template <class _Tp> struct remove_all_extents
		{typedef _Tp type;};
	template <class _Tp> struct remove_all_extents<_Tp[]>
		{typedef typename remove_all_extents<_Tp>::type type;};
	template <class _Tp, size_t _Np> struct remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};

	// is_pointer
	template <class _Tp> struct __libcpp_is_pointer       : public false_type {};
	template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

	template <class _Tp> struct is_pointer
		: public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};

	// is_reference
	template <class _Tp> struct is_lvalue_reference       : public false_type {};
	template <class _Tp> struct is_lvalue_reference<_Tp&> : public true_type {};

	template <class _Tp> struct is_rvalue_reference        : public false_type {};
	template <class _Tp> struct is_rvalue_reference<_Tp&&> : public true_type {};

	template <class _Tp> struct is_reference        : public false_type {};
	template <class _Tp> struct is_reference<_Tp&>  : public true_type {};
	template <class _Tp> struct is_reference<_Tp&&> : public true_type {};

	// is_union
	template <class _Tp> struct __libcpp_union : public false_type {};
	template <class _Tp> struct is_union
		: public __libcpp_union<typename remove_cv<_Tp>::type> {};

	// is_class
	namespace __is_class_imp
	{
	template <class _Tp> char  __test(int _Tp::*);
	template <class _Tp> __two __test(...);
	}

	template <class _Tp> struct is_class
		: public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};

	// is_function
	namespace __libcpp_is_function_imp
	{
	struct __dummy_type {};
	template <class _Tp> char  __test(_Tp*);
	template <class _Tp> char __test(__dummy_type);
	template <class _Tp> __two __test(...);
	template <class _Tp> _Tp&  __source(int);
	template <class _Tp> __dummy_type __source(...);
	}

	template <class _Tp, bool = is_class<_Tp>::value ||
								is_union<_Tp>::value ||
								is_void<_Tp>::value  ||
								is_reference<_Tp>::value ||
								__is_nullptr_t<_Tp>::value >
	struct __libcpp_is_function
		: public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>
		{};
	template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

	template <class _Tp> struct is_function
		: public __libcpp_is_function<_Tp> {};


	// alignment_of
	template <class _Tp> struct alignment_of
		: public integral_constant<size_t, __alignof__(_Tp)> {};


	// is_member_function_pointer
	// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
	// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
	//
	template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
	struct __member_pointer_traits_imp
	{  // forward declaration; specializations later
	};

	template <class _Tp> struct __libcpp_is_member_function_pointer
		: public false_type {};

	template <class _Ret, class _Class>
	struct __libcpp_is_member_function_pointer<_Ret _Class::*>
		: public is_function<_Ret> {};

	template <class _Tp> struct is_member_function_pointer
		: public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};

	// is_member_pointer
	template <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};
	template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

	template <class _Tp> struct is_member_pointer
		: public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};

	// is_member_object_pointer
	template <class _Tp> struct is_member_object_pointer
		: public integral_constant<bool, is_member_pointer<_Tp>::value &&
										!is_member_function_pointer<_Tp>::value> {};

	// is_enum
	template <class _Tp> struct is_enum
		: public integral_constant<bool, !is_void<_Tp>::value             &&
										!is_integral<_Tp>::value         &&
										!is_floating_point<_Tp>::value   &&
										!is_array<_Tp>::value            &&
										!is_pointer<_Tp>::value          &&
										!is_reference<_Tp>::value        &&
										!is_member_pointer<_Tp>::value   &&
										!is_union<_Tp>::value            &&
										!is_class<_Tp>::value            &&
										!is_function<_Tp>::value         > {};

	// is_fundamental
	template <class _Tp> struct is_fundamental
		: public integral_constant<bool, is_void<_Tp>::value        ||
										__is_nullptr_t<_Tp>::value ||
										is_arithmetic<_Tp>::value> {};

	// is_scalar
	template <class _Tp> struct is_scalar
		: public integral_constant<bool, is_arithmetic<_Tp>::value     ||
		is_member_pointer<_Tp>::value ||
		is_pointer<_Tp>::value        ||
		__is_nullptr_t<_Tp>::value    ||
		is_enum<_Tp>::value           > {};

	template <> struct is_scalar<nullptr_t> : public true_type {};

	// __is_referenceable  [defns.referenceable]
	struct __is_referenceable_impl {
		template <class _Tp> static _Tp& __test(int);
		template <class _Tp> static __two __test(...);
	};

	template <class _Tp>
	struct __is_referenceable : integral_constant<bool,
		!is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};


	// add_lvalue_reference
	template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };
	template <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };

	template <class _Tp> struct add_lvalue_reference
	{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};

	struct __any
	{
		__any(...);
	};

	// add_pointer
	template <class _Tp,
		bool = __is_referenceable<_Tp>::value ||
		is_same<typename remove_cv<_Tp>::type, void>::value>
	struct __add_pointer_impl
		{typedef typename remove_reference<_Tp>::type* type;};
	template <class _Tp> struct __add_pointer_impl<_Tp, false>
		{typedef _Tp type;};

	template <class _Tp> struct add_pointer
		{typedef typename __add_pointer_impl<_Tp>::type type;};

	// add_const
	template <class _Tp, bool = is_reference<_Tp>::value ||
								is_function<_Tp>::value  ||
								is_const<_Tp>::value     >
	struct __add_const             {typedef _Tp type;};

	template <class _Tp>
	struct __add_const<_Tp, false> {typedef const _Tp type;};

	template <class _Tp> struct add_const
		{typedef typename __add_const<_Tp>::type type;};

	template <class _Tp> using add_const_t = typename add_const<_Tp>::type;


	// add_volatile
	template <class _Tp, bool = is_reference<_Tp>::value ||
								is_function<_Tp>::value  ||
								is_volatile<_Tp>::value  >
	struct __add_volatile             {typedef _Tp type;};

	template <class _Tp>
	struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

	template <class _Tp> struct add_volatile
		{typedef typename __add_volatile<_Tp>::type type;};

	template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;


	// is_destructible
	//  if it's a reference, return true
	//  if it's a function, return false
	//  if it's   void,     return false
	//  if it's an array of unknown bound, return false
	//  Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
	//    where _Up is remove_all_extents<_Tp>::type
	template <class>
	struct __is_destructible_apply { typedef int type; };

	template <typename _Tp>
	struct __is_destructor_wellformed {
		template <typename _Tp1>
		static char  __test (
			typename __is_destructible_apply<decltype(std::declval<_Tp1&>().~_Tp1())>::type
		);

		template <typename _Tp1>
		static __two __test (...);

		static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
	};

	template <class _Tp, bool>
	struct __destructible_imp;

	template <class _Tp>
	struct __destructible_imp<_Tp, false>
	: public std::integral_constant<bool,
			__is_destructor_wellformed<typename std::remove_all_extents<_Tp>::type>::value> {};

	template <class _Tp>
	struct __destructible_imp<_Tp, true>
		: public std::true_type {};

	template <class _Tp, bool>
	struct __destructible_false;

	template <class _Tp>
	struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::is_reference<_Tp>::value> {};

	template <class _Tp>
	struct __destructible_false<_Tp, true> : public std::false_type {};

	template <class _Tp>
	struct is_destructible
		: public __destructible_false<_Tp, std::is_function<_Tp>::value> {};

	template <class _Tp>
	struct is_destructible<_Tp[]>
		: public std::false_type {};

	template <>
	struct is_destructible<void>
		: public std::false_type {};

	// move
	template <class _Tp>
	inline constexpr typename remove_reference<_Tp>::type&& move(_Tp&& __t) noexcept {
		typedef typename remove_reference<_Tp>::type _Up;
		return static_cast<_Up&&>(__t);
	}

	template <class _Tp>
	inline constexpr _Tp&& forward(typename remove_reference<_Tp>::type& __t) noexcept {
		return static_cast<_Tp&&>(__t);
	}

	template <class _Tp>
	inline constexpr _Tp&& forward(typename remove_reference<_Tp>::type&& __t) noexcept {
		static_assert(!is_lvalue_reference<_Tp>::value, "can not forward an rvalue as an lvalue");
		return static_cast<_Tp&&>(__t);
	}


	// remove_extent
	template <class _Tp> struct remove_extent
		{typedef _Tp type;};
	template <class _Tp> struct remove_extent<_Tp[]>
		{typedef _Tp type;};
	template <class _Tp, size_t _Np> struct remove_extent<_Tp[_Np]>
		{typedef _Tp type;};

	// decay
	template <class _Up, bool>
	struct __decay {
		typedef typename remove_cv<_Up>::type type;
	};

	template <class _Up>
	struct __decay<_Up, true> {
	public:
		typedef typename conditional
						<
							is_array<_Up>::value,
							typename remove_extent<_Up>::type*,
							typename conditional
							<
								is_function<_Up>::value,
								typename add_pointer<_Up>::type,
								typename remove_cv<_Up>::type
							>::type
						>::type type;
	};

	template <class _Tp>
	struct decay
	{
	private:
		typedef typename remove_reference<_Tp>::type _Up;
	public:
		typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
	};

	template <class _Tp> using decay_t = typename decay<_Tp>::type;


		template <class _Tp, class _Up = void, class _Vp = void>
	struct common_type
	{
	public:
		typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;
	};


	template <>
	struct common_type<void, void, void>
	{
	public:
		typedef void type;
	};

	template <class _Tp>
	struct common_type<_Tp, void, void>
	{
	public:
		typedef typename common_type<_Tp, _Tp>::type type;
	};

	template <class _Tp, class _Up>
	struct common_type<_Tp, _Up, void>
	{
		typedef typename decay<decltype(
			true ? std::declval<_Tp>() : std::declval<_Up>()
		)>::type type;
	};


	// is_base_of
	namespace __is_base_of_imp
	{
	template <class _Tp>
	struct _Dst
	{
		_Dst(const volatile _Tp &);
	};
	template <class _Tp>
	struct _Src
	{
		operator const volatile _Tp &();
		template <class _Up> operator const _Dst<_Up> &();
	};
	template <size_t> struct __one { typedef char type; };
	template <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
	template <class _Bp, class _Dp> __two __test(...);
	}

	template <class _Bp, class _Dp>
	struct is_base_of
		: public integral_constant<bool, is_class<_Bp>::value &&
		sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};

	// is_convertible
	namespace __is_convertible_imp
	{
	template <class _Tp> void  __test_convert(_Tp);

	template <class _From, class _To, class = void>
	struct __is_convertible_test : public false_type {};

	template <class _From, class _To>
	struct __is_convertible_test<_From, _To,
		decltype(std::__is_convertible_imp::__test_convert<_To>(std::declval<_From>()))> : public true_type
	{};

	template <class _Tp, bool _IsArray =    is_array<_Tp>::value,
						bool _IsFunction = is_function<_Tp>::value,
						bool _IsVoid =     is_void<_Tp>::value>
						struct __is_array_function_or_void                          {enum {value = 0};};
	template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
	template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
	template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
	}

	template <class _Tp,
		unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
	struct __is_convertible_check
	{
		static const size_t __v = 0;
	};

	template <class _Tp>
	struct __is_convertible_check<_Tp, 0>
	{
		static const size_t __v = sizeof(_Tp);
	};

	template <class _T1, class _T2,
		unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
		unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
	struct __is_convertible
		: public integral_constant<bool,
			__is_convertible_imp::__is_convertible_test<_T1, _T2>::value
		>
	{};

	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};

	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};

	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
	template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};

	template <class _T1, class _T2> struct is_convertible
		: public __is_convertible<_T1, _T2>
	{
		static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
		static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
	};


	struct __nat
	{
		__nat() = delete;
		__nat(const __nat&) = delete;
		__nat& operator=(const __nat&) = delete;
		~__nat() = delete;
	};


	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
	{
		typedef _Class _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
	{
		typedef _Class _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param..., ...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
	{
		typedef _Class const _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
	{
		typedef _Class const _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param..., ...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
	{
		typedef _Class volatile _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
	{
		typedef _Class volatile _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param..., ...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
	{
		typedef _Class const volatile _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param...);
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
	{
		typedef _Class const volatile _ClassType;
		typedef _Rp _ReturnType;
		typedef _Rp (_FnType) (_Param..., ...);
	};

	template <class _Rp, class _Class>
	struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
	{
		typedef _Class _ClassType;
		typedef _Rp _ReturnType;
	};

	template <class _MP>
	struct __member_pointer_traits
		: public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
		is_member_function_pointer<_MP>::value,
		is_member_object_pointer<_MP>::value>
	{
	//     typedef ... _ClassType;
	//     typedef ... _ReturnType;
	//     typedef ... _FnType;
	};


	template <class _DecayedFp>
	struct __member_pointer_class_type {};

	template <class _Ret, class _ClassType>
	struct __member_pointer_class_type<_Ret _ClassType::*> {
	typedef _ClassType type;
	};


	template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
	bool = is_volatile<typename remove_reference<_Tp>::type>::value>
	struct __apply_cv
	{
		typedef _Up type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp, _Up, true, false>
	{
		typedef const _Up type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp, _Up, false, true>
	{
		typedef volatile _Up type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp, _Up, true, true>
	{
		typedef const volatile _Up type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp&, _Up, false, false>
	{
		typedef _Up& type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp&, _Up, true, false>
	{
		typedef const _Up& type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp&, _Up, false, true>
	{
		typedef volatile _Up& type;
	};

	template <class _Tp, class _Up>
	struct __apply_cv<_Tp&, _Up, true, true>
	{
		typedef const volatile _Up& type;
	};



	template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
	template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
	template <class _Tp> struct __is_reference_wrapper
		: public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};


	// Check for complete types
	template <class ..._Tp> struct __check_complete;

	template <>
	struct __check_complete<>
	{
	};

	template <class _Hp, class _T0, class ..._Tp>
	struct __check_complete<_Hp, _T0, _Tp...>
		: private __check_complete<_Hp>,
		private __check_complete<_T0, _Tp...>
	{
	};

	template <class _Hp>
	struct __check_complete<_Hp, _Hp>
		: private __check_complete<_Hp>
	{
	};

	template <class _Tp>
	struct __check_complete<_Tp>
	{
		static_assert(sizeof(_Tp) > 0, "Type must be complete.");
	};

	template <class _Tp>
	struct __check_complete<_Tp&>
		: private __check_complete<_Tp>
	{
	};

	template <class _Tp>
	struct __check_complete<_Tp&&>
		: private __check_complete<_Tp>
	{
	};

	template <class _Rp, class ..._Param>
	struct __check_complete<_Rp (*)(_Param...)>
		: private __check_complete<_Rp>
	{
	};

	template <class ..._Param>
	struct __check_complete<void (*)(_Param...)>
	{
	};

	template <class _Rp, class ..._Param>
	struct __check_complete<_Rp (_Param...)>
		: private __check_complete<_Rp>
	{
	};

	template <class ..._Param>
	struct __check_complete<void (_Param...)>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...)>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) const>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) &>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) const&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) &&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class, class ..._Param>
	struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
		: private __check_complete<_Class>
	{
	};

	template <class _Rp, class _Class>
	struct __check_complete<_Rp _Class::*>
		: private __check_complete<_Class>
	{
	};


	template <class _Fp, class _A0,
			class _DecayFp = typename decay<_Fp>::type,
			class _DecayA0 = typename decay<_A0>::type,
			class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
	using __enable_if_bullet1 = typename enable_if
		<
			is_member_function_pointer<_DecayFp>::value
			&& is_base_of<_ClassT, _DecayA0>::value
		>::type;

	template <class _Fp, class _A0,
			class _DecayFp = typename decay<_Fp>::type,
			class _DecayA0 = typename decay<_A0>::type>
	using __enable_if_bullet2 = typename enable_if
		<
			is_member_function_pointer<_DecayFp>::value
			&& __is_reference_wrapper<_DecayA0>::value
		>::type;

	template <class _Fp, class _A0,
			class _DecayFp = typename decay<_Fp>::type,
			class _DecayA0 = typename decay<_A0>::type,
			class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
	using __enable_if_bullet3 = typename enable_if
		<
			is_member_function_pointer<_DecayFp>::value
			&& !is_base_of<_ClassT, _DecayA0>::value
			&& !__is_reference_wrapper<_DecayA0>::value
		>::type;

	template <class _Fp, class _A0,
			class _DecayFp = typename decay<_Fp>::type,
			class _DecayA0 = typename decay<_A0>::type,
			class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
	using __enable_if_bullet4 = typename enable_if
		<
			is_member_object_pointer<_DecayFp>::value
			&& is_base_of<_ClassT, _DecayA0>::value
		>::type;

	template <class _Fp, class _A0,
			class _DecayFp = typename decay<_Fp>::type,
			class _DecayA0 = typename decay<_A0>::type>
	using __enable_if_bullet5 = typename enable_if
		<
			is_member_object_pointer<_DecayFp>::value
			&& __is_reference_wrapper<_DecayA0>::value
		>::type;

	template <class _Fp, class _A0,
			class _DecayFp = typename decay<_Fp>::type,
			class _DecayA0 = typename decay<_A0>::type,
			class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
	using __enable_if_bullet6 = typename enable_if
		<
			is_member_object_pointer<_DecayFp>::value
			&& !is_base_of<_ClassT, _DecayA0>::value
			&& !__is_reference_wrapper<_DecayA0>::value
		>::type;

	// __invoke forward declarations

	// fall back - none of the bullets

	#define _LIBCPP_INVOKE_RETURN(...) \
		noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \
		{ return __VA_ARGS__; }

	template <class ..._Args>
	auto __invoke(__any, _Args&& ...__args) -> __nat;

	template <class ..._Args>
	auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;

	// bullets 1, 2 and 3

	template <class _Fp, class _A0, class ..._Args,
			class = __enable_if_bullet1<_Fp, _A0>>
	inline
	auto
	__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN((std::forward<_A0>(__a0).*__f)(std::forward<_Args>(__args)...))

	template <class _Fp, class _A0, class ..._Args,
			class = __enable_if_bullet1<_Fp, _A0>>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN((std::forward<_A0>(__a0).*__f)(std::forward<_Args>(__args)...))

	template <class _Fp, class _A0, class ..._Args,
			class = __enable_if_bullet2<_Fp, _A0>>
	inline
	auto
	__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(std::forward<_Args>(__args)...))

	template <class _Fp, class _A0, class ..._Args,
			class = __enable_if_bullet2<_Fp, _A0>>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(std::forward<_Args>(__args)...))

	template <class _Fp, class _A0, class ..._Args,
			class = __enable_if_bullet3<_Fp, _A0>>
	inline
	auto
	__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN(((*std::forward<_A0>(__a0)).*__f)(std::forward<_Args>(__args)...))

	template <class _Fp, class _A0, class ..._Args,
			class = __enable_if_bullet3<_Fp, _A0>>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN(((*std::forward<_A0>(__a0)).*__f)(std::forward<_Args>(__args)...))

	// bullets 4, 5 and 6

	template <class _Fp, class _A0,
			class = __enable_if_bullet4<_Fp, _A0>>
	inline
	auto
	__invoke(_Fp&& __f, _A0&& __a0)
	_LIBCPP_INVOKE_RETURN(std::forward<_A0>(__a0).*__f)

	template <class _Fp, class _A0,
			class = __enable_if_bullet4<_Fp, _A0>>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _A0&& __a0)
	_LIBCPP_INVOKE_RETURN(std::forward<_A0>(__a0).*__f)

	template <class _Fp, class _A0,
			class = __enable_if_bullet5<_Fp, _A0>>
	inline
	auto
	__invoke(_Fp&& __f, _A0&& __a0)
	_LIBCPP_INVOKE_RETURN(__a0.get().*__f)

	template <class _Fp, class _A0,
			class = __enable_if_bullet5<_Fp, _A0>>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _A0&& __a0)
	_LIBCPP_INVOKE_RETURN(__a0.get().*__f)

	template <class _Fp, class _A0,
			class = __enable_if_bullet6<_Fp, _A0>>
	inline
	auto
	__invoke(_Fp&& __f, _A0&& __a0)
	_LIBCPP_INVOKE_RETURN((*std::forward<_A0>(__a0)).*__f)

	template <class _Fp, class _A0,
			class = __enable_if_bullet6<_Fp, _A0>>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _A0&& __a0)
	_LIBCPP_INVOKE_RETURN((*std::forward<_A0>(__a0)).*__f)

	// bullet 7

	template <class _Fp, class ..._Args>
	inline
	auto
	__invoke(_Fp&& __f, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN(std::forward<_Fp>(__f)(std::forward<_Args>(__args)...))

	template <class _Fp, class ..._Args>
	inline
	constexpr auto
	__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
	_LIBCPP_INVOKE_RETURN(std::forward<_Fp>(__f)(std::forward<_Args>(__args)...))

	#undef _LIBCPP_INVOKE_RETURN


	// __invokable
	template <class _Ret, class _Fp, class ..._Args>
	struct __invokable_r
		: private __check_complete<_Fp>
	{
		using _Result = decltype(
			std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));

		using type =
			typename conditional<
				!is_same<_Result, __nat>::value,
				typename conditional<
					is_void<_Ret>::value,
					true_type,
					is_convertible<_Result, _Ret>
				>::type,
				false_type
			>::type;
		static const bool value = type::value;
	};

	template <class _Fp, class ..._Args>
	using __invokable = __invokable_r<void, _Fp, _Args...>;

	template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
	struct __nothrow_invokable_r_imp {
	static const bool value = false;
	};

	template <class _Ret, class _Fp, class ..._Args>
	struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
	{
		typedef __nothrow_invokable_r_imp _ThisT;

		template <class _Tp>
		static void __test_noexcept(_Tp) noexcept;

		static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
			std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...)));
	};

	template <class _Ret, class _Fp, class ..._Args>
	struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
	{
		static const bool value = noexcept(
			std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));
	};

	template <class _Ret, class _Fp, class ..._Args>
	using __nothrow_invokable_r =
		__nothrow_invokable_r_imp<
				__invokable_r<_Ret, _Fp, _Args...>::value,
				is_void<_Ret>::value,
				_Ret, _Fp, _Args...
		>;

	template <class _Fp, class ..._Args>
	using __nothrow_invokable =
		__nothrow_invokable_r_imp<
				__invokable<_Fp, _Args...>::value,
				true, void, _Fp, _Args...
		>;

	template <class _Fp, class ..._Args>
	struct __invoke_of
		: public enable_if<
			__invokable<_Fp, _Args...>::value,
			typename __invokable_r<void, _Fp, _Args...>::_Result>
	{
	};

	// result_of
	template <class _Callable> class result_of;

	template <class _Fn, bool, bool>
	class __result_of
	{
	};

	template <class _Fn>
	class __result_of<_Fn(), true, false>
	{
	public:
		typedef decltype(declval<_Fn>()()) type;
	};

	template <class _Fn, class _A0>
	class __result_of<_Fn(_A0), true, false>
	{
	public:
		typedef decltype(declval<_Fn>()(declval<_A0>())) type;
	};

	template <class _Fn, class _A0, class _A1>
	class __result_of<_Fn(_A0, _A1), true, false>
	{
	public:
		typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
	};

	template <class _Fn, class _A0, class _A1, class _A2>
	class __result_of<_Fn(_A0, _A1, _A2), true, false>
	{
	public:
		typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
	};

	template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
	struct __result_of_mp;

	// member function pointer
	template <class _MP, class _Tp>
	struct __result_of_mp<_MP, _Tp, true>
		: public __identity<typename __member_pointer_traits<_MP>::_ReturnType>
	{
	};

	// member data pointer
	template <class _MP, class _Tp, bool>
	struct __result_of_mdp;

	template <class _Rp, class _Class, class _Tp>
	struct __result_of_mdp<_Rp _Class::*, _Tp, false>
	{
		typedef typename __apply_cv<decltype(*std::declval<_Tp>()), _Rp>::type& type;
	};

	template <class _Rp, class _Class, class _Tp>
	struct __result_of_mdp<_Rp _Class::*, _Tp, true>
	{
		typedef typename __apply_cv<_Tp, _Rp>::type& type;
	};

	template <class _Rp, class _Class, class _Tp>
	struct __result_of_mp<_Rp _Class::*, _Tp, false>
		: public __result_of_mdp<_Rp _Class::*, _Tp,
		is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
	{
	};

	template <class _Fn, class _Tp>
	class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
		: public __result_of_mp<typename remove_reference<_Fn>::type,
		_Tp,
		is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
	{
	};

	template <class _Fn, class _Tp, class _A0>
	class __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
		: public __result_of_mp<typename remove_reference<_Fn>::type,
		_Tp,
		is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
	{
	};

	template <class _Fn, class _Tp, class _A0, class _A1>
	class __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
		: public __result_of_mp<typename remove_reference<_Fn>::type,
		_Tp,
		is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
	{
	};

	template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
	class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
		: public __result_of_mp<typename remove_reference<_Fn>::type,
		_Tp,
		is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
	{
	};

	// result_of
	template <class _Fn>
	class result_of<_Fn()>
		: public __result_of<_Fn(),
		is_class<typename remove_reference<_Fn>::type>::value ||
		is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
		is_member_pointer<typename remove_reference<_Fn>::type>::value
		>
	{
	};

	template <class _Fn, class _A0>
	class result_of<_Fn(_A0)>
		: public __result_of<_Fn(_A0),
		is_class<typename remove_reference<_Fn>::type>::value ||
		is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
		is_member_pointer<typename remove_reference<_Fn>::type>::value
		>
	{
	};

	template <class _Fn, class _A0, class _A1>
	class result_of<_Fn(_A0, _A1)>
		: public __result_of<_Fn(_A0, _A1),
		is_class<typename remove_reference<_Fn>::type>::value ||
		is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
		is_member_pointer<typename remove_reference<_Fn>::type>::value
		>
	{
	};

	template <class _Fn, class _A0, class _A1, class _A2>
	class result_of<_Fn(_A0, _A1, _A2)>
		: public __result_of<_Fn(_A0, _A1, _A2),
		is_class<typename remove_reference<_Fn>::type>::value ||
		is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,
		is_member_pointer<typename remove_reference<_Fn>::type>::value
		>
	{
	};


	namespace __is_construct
	{
	struct __nat {};
	}

	template <class _Tp, class... _Args>
	struct __libcpp_is_constructible;

	template <class _To, class _From>
	struct __is_invalid_base_to_derived_cast {
	static_assert(is_reference<_To>::value, "Wrong specialization");
	using _RawFrom = __uncvref_t<_From>;
	using _RawTo = __uncvref_t<_To>;
	static const bool value = __lazy_and<
			__lazy_not<is_same<_RawFrom, _RawTo>>,
			is_base_of<_RawFrom, _RawTo>,
			__lazy_not<__libcpp_is_constructible<_RawTo, _From>>
	>::value;
	};

	template <class _To, class _From>
	struct __is_invalid_lvalue_to_rvalue_cast : false_type {
	static_assert(is_reference<_To>::value, "Wrong specialization");
	};

	template <class _ToRef, class _FromRef>
	struct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {
	using _RawFrom = __uncvref_t<_FromRef>;
	using _RawTo = __uncvref_t<_ToRef>;
	static const bool value = __lazy_and<
		__lazy_not<is_function<_RawTo>>,
		__lazy_or<
			is_same<_RawFrom, _RawTo>,
			is_base_of<_RawTo, _RawFrom>>
		>::value;
	};


	struct __is_constructible_helper
	{
		template <class _To>
		static void __eat(_To);

		// This overload is needed to work around a Clang bug that disallows
		// static_cast<T&&>(e) for non-reference-compatible types.
		// Example: static_cast<int&&>(declval<double>());
		// NOTE: The static_cast implementation below is required to support
		//  classes with explicit conversion operators.
		template <class _To, class _From,
				class = decltype(__eat<_To>(std::declval<_From>()))>
		static true_type __test_cast(int);

		template <class _To, class _From,
				class = decltype(static_cast<_To>(std::declval<_From>()))>
		static integral_constant<bool,
			!__is_invalid_base_to_derived_cast<_To, _From>::value &&
			!__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value
		> __test_cast(long);

		template <class, class>
		static false_type __test_cast(...);

		template <class _Tp, class ..._Args,
			class = decltype(_Tp(std::declval<_Args>()...))>
		static true_type __test_nary(int);
		template <class _Tp, class...>
		static false_type __test_nary(...);

		template <class _Tp, class _A0, class = decltype(::new _Tp(std::declval<_A0>()))>
		static is_destructible<_Tp> __test_unary(int);
		template <class, class>
		static false_type __test_unary(...);
	};

	template <class _Tp, bool = is_void<_Tp>::value>
	struct __is_default_constructible
		: decltype(__is_constructible_helper::__test_nary<_Tp>(0))
	{};

	template <class _Tp>
	struct __is_default_constructible<_Tp, true> : false_type {};

	template <class _Tp>
	struct __is_default_constructible<_Tp[], false> : false_type {};

	template <class _Tp, size_t _Nx>
	struct __is_default_constructible<_Tp[_Nx], false>
		: __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};

	template <class _Tp, class... _Args>
	struct __libcpp_is_constructible
	{
	static_assert(sizeof...(_Args) > 1, "Wrong specialization");
	typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))
		type;
	};

	template <class _Tp>
	struct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};

	template <class _Tp, class _A0>
	struct __libcpp_is_constructible<_Tp, _A0>
		: public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))
	{};

	template <class _Tp, class _A0>
	struct __libcpp_is_constructible<_Tp&, _A0>
		: public decltype(__is_constructible_helper::
		__test_cast<_Tp&, _A0>(0))
	{};

	template <class _Tp, class _A0>
	struct __libcpp_is_constructible<_Tp&&, _A0>
		: public decltype(__is_constructible_helper::
		__test_cast<_Tp&&, _A0>(0))
	{};


	template <class _Tp, class... _Args>
	struct is_constructible
		: public __libcpp_is_constructible<_Tp, _Args...>::type {};


	// is_default_constructible
	template <class _Tp>
	struct is_default_constructible
		: public is_constructible<_Tp>
		{};

	// is_copy_constructible
	template <class _Tp>
	struct is_copy_constructible
		: public is_constructible<_Tp,
		typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};

	// is_move_constructible
	template <class _Tp>
	struct is_move_constructible
		: public is_copy_constructible<_Tp>
		{};

	// is_trivially_constructible
	template <class _Tp, class _A0 = __is_construct::__nat,
						class _A1 = __is_construct::__nat>
	struct  is_trivially_constructible
		: false_type
	{
	};

	template <class _Tp>
	struct is_trivially_constructible<_Tp, __is_construct::__nat,
														__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	template <class _Tp>
	struct is_trivially_constructible<_Tp, _Tp,
														__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	template <class _Tp>
	struct is_trivially_constructible<_Tp, const _Tp&,
														__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	template <class _Tp>
	struct is_trivially_constructible<_Tp, _Tp&,
														__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	// is_trivially_default_constructible
	template <class _Tp> struct is_trivially_default_constructible
		: public is_trivially_constructible<_Tp>
		{};

	// is_trivially_copy_constructible
	template <class _Tp> struct is_trivially_copy_constructible
		: public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
		{};

	// is_trivially_move_constructible
	template <class _Tp> struct is_trivially_move_constructible
		: public is_trivially_copy_constructible<_Tp>
		{};

	// is_nothrow_constructible
	template <class _Tp, class _A0 = __is_construct::__nat,
	class _A1 = __is_construct::__nat>
	struct is_nothrow_constructible
		: false_type
	{
	};

	template <class _Tp>
	struct is_nothrow_constructible<_Tp, __is_construct::__nat,
		__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	template <class _Tp>
	struct  is_nothrow_constructible<_Tp, _Tp,
		__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	template <class _Tp>
	struct is_nothrow_constructible<_Tp, const _Tp&,
		__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	template <class _Tp>
	struct is_nothrow_constructible<_Tp, _Tp&,
		__is_construct::__nat>
		: integral_constant<bool, is_scalar<_Tp>::value>
	{
	};

	// is_nothrow_copy_constructible
	template <class _Tp> struct is_nothrow_copy_constructible
		: public is_nothrow_constructible<_Tp,
		typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};

	// is_nothrow_move_constructible
	template <class _Tp> struct is_nothrow_move_constructible
		: public is_nothrow_copy_constructible<_Tp>
    {};

	// is_trivially_destructible
	template <class _Tp> struct __libcpp_trivial_destructor
		: public integral_constant<bool, is_scalar<_Tp>::value ||
		is_reference<_Tp>::value> {};

	template <class _Tp> struct is_trivially_destructible
		: public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};

	template <class _Tp> struct is_trivially_destructible<_Tp[]>
		: public false_type {};

} /* namespace std */

#pragma GCC visibility pop

#endif // __HEADER_TYPE_TRAITS
